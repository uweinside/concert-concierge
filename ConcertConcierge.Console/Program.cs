// ============================================================================
// CONCERT CONCIERGE - Azure AI Agents Demo Application
// ============================================================================
// This application demonstrates how to:
// 1. Create an AI agent with custom function tools (Ticketmaster API)
// 2. Enable Code Interpreter for Python code execution
// 3. Handle multi-turn conversations with thread-based context
// 4. Execute custom tools and return results to the agent
// 5. Download files generated by the Code Interpreter
// ============================================================================

using Azure;
using Azure.AI.Agents.Persistent;
using Azure.Core;
using Azure.Identity;
using ConcertConcierge.TicketMaster;
using Microsoft.Extensions.Configuration;
using System.Text.Json;

// ============================================================================
// CONFIGURATION: Load secrets from user secrets storage
// ============================================================================
// User secrets keep sensitive data (API keys, endpoints) out of source control.
// Configure with: dotnet user-secrets set "Key" "Value"
// ============================================================================

var configuration = new ConfigurationBuilder()
    .AddUserSecrets<Program>()  // Loads secrets from ~/.microsoft/usersecrets/
    .Build();

// Extract configuration values
var projectEndpoint = configuration["ProjectEndpoint"];              // Azure AI Foundry project URL
var modelDeploymentName = configuration["ModelDeploymentName"] ?? "gpt-4o";  // AI model to use
var ticketMasterApiKey = configuration["TicketMasterApiKey"];        // Ticketmaster API key

// ============================================================================
// VALIDATION: Ensure required configuration is present
// ============================================================================

if (string.IsNullOrEmpty(projectEndpoint))
{
    Console.WriteLine("Error: ProjectEndpoint not found in user secrets.");
    Console.WriteLine("Please set it using: dotnet user-secrets set \"ProjectEndpoint\" \"<your-endpoint>\"");
    Console.WriteLine("Format: https://<AIFoundryResourceName>.services.ai.azure.com/api/projects/<ProjectName>");
    Console.WriteLine("Find this in Azure AI Foundry portal under Project Overview > Libraries > Foundry.");
    return;
}

if (string.IsNullOrEmpty(ticketMasterApiKey) || ticketMasterApiKey == "YOUR_API_KEY_HERE")
{
    Console.WriteLine("Error: TicketMasterApiKey not found or not configured in user secrets.");
    Console.WriteLine("Please set it using: dotnet user-secrets set \"TicketMasterApiKey\" \"<your-api-key>\"");
    Console.WriteLine("Get your API key from: https://developer.ticketmaster.com/");
    return;
}

// ============================================================================
// INITIALIZE: Create HTTP client for Ticketmaster API
// ============================================================================
// This client will be called by our custom function tool when the agent
// requests concert information from Ticketmaster.
// ============================================================================

var ticketMasterClient = new TicketMasterClient(ticketMasterApiKey);

Console.WriteLine("Concert Concierge - AI Agent");
Console.WriteLine("==============================\n");
Console.WriteLine("Authenticating with Azure CLI credentials...");
Console.WriteLine("Make sure you're logged into the same Azure account that has access to your Foundry project.");
Console.WriteLine("Use 'az login' to switch accounts if needed.\n");

// ============================================================================
// AZURE AI CLIENT: Connect to Azure AI Foundry
// ============================================================================
// PersistentAgentsClient is the main entry point for working with Azure AI Agents.
// It provides access to:
//   - Administration: Create/manage agents
//   - Threads: Manage conversation threads
//   - Messages: Send/receive messages
//   - Runs: Execute agent on a thread
//   - Files: Upload/download files
// ============================================================================

PersistentAgentsClient client = new(
    projectEndpoint,
    new AzureCliCredential()  // Uses 'az login' credentials for authentication
);

// ============================================================================
// DEFINE CUSTOM TOOL: Ticketmaster Event Search
// ============================================================================
// FunctionToolDefinition tells the agent:
//   1. WHAT the function does (description)
//   2. WHEN to use it (based on description matching user intent)
//   3. WHAT parameters it accepts (JSON schema)
//
// The AI model will automatically decide to call this function when users
// ask about concerts, events, or shows.
// ============================================================================

var searchEventsTool = new FunctionToolDefinition(
    // Function name: Used to identify which function the agent wants to call
    name: "search_ticketmaster_events",
    
    // Description: Helps the AI understand WHEN to use this tool
    // Be specific and include keywords that match user queries
    description: "Search for concert and event information using the Ticketmaster API. " +
                 "Returns event details including name, date, venue, location, and pricing. " +
                 "IMPORTANT: Always provide countryCode for international cities " +
                 "(e.g., 'DE' for Germany, 'GB' for UK, 'CA' for Canada). Use 'US' for United States.",
    
    // Parameters: JSON Schema defining function inputs
    // The AI will extract these values from user messages and pass them to your function
    parameters: BinaryData.FromString("""
    {
        "type": "object",
        "properties": {
            "keyword": {
                "type": "string",
                "description": "Search keyword - artist name, event name, or venue name"
            },
            "city": {
                "type": "string",
                "description": "City name to search in (e.g., 'Seattle', 'New York', 'Munich', 'London')"
            },
            "stateCode": {
                "type": "string",
                "description": "US state code (e.g., 'WA', 'NY', 'CA'). Only use for United States cities."
            },
            "countryCode": {
                "type": "string",
                "description": "ISO 3166-1 country code (REQUIRED for international searches). Examples: 'US' for USA, 'DE' for Germany, 'GB' for UK, 'FR' for France, 'CA' for Canada, 'AU' for Australia"
            },
            "classificationName": {
                "type": "string",
                "description": "Event classification (e.g., 'Music', 'Sports', 'Arts & Theatre')"
            }
        },
        "required": []
    }
    """)
);

// ============================================================================
// CREATE AGENT: AI Assistant with Custom Tools
// ============================================================================
// The agent combines:
//   - An AI model (GPT-4o)
//   - System instructions (personality/behavior)
//   - Tools it can use (custom functions, code interpreter, etc.)
//
// For each session, we create a fresh agent to ensure it has the latest
// tool definitions. In production, you might reuse agents.
// ============================================================================

Console.WriteLine("Creating new agent with Ticketmaster search tool...");

var agentResponse = client.Administration.CreateAgent(
    // Model: The AI model to use (must be deployed in your Azure AI Foundry project)
    model: modelDeploymentName,
    
    // Name: Friendly identifier for this agent
    name: "Concert Concierge",
    
    // Instructions: System prompt that defines the agent's personality and behavior
    // This is like giving the AI a "job description"
    instructions: "You are a helpful concert concierge assistant. " +
                  "You help users find information about concerts, artists, venues, " +
                  "and help them plan their concert experiences. " +
                  "Use the Ticketmaster search tool to find real event data when users ask about concerts, shows, or events. " +
                  "You can also use the code interpreter to create visualizations, PDFs, and other files for users.",
    
    // Tools: List of capabilities the agent can use
    // The AI will automatically choose the right tool based on the user's request
    tools: new List<ToolDefinition>
    {
        searchEventsTool,                      // ‚≠ê Custom tool: Ticketmaster API search
        new CodeInterpreterToolDefinition()    // ‚≠ê Built-in tool: Python code execution sandbox
    }
);

// Extract the agent from the response
var agent = agentResponse.Value;
Console.WriteLine($"‚úì Created agent with ID: {agent.Id}\n");

// ============================================================================
// CREATE THREAD: Start a Conversation Session
// ============================================================================
// A thread represents a conversation session and maintains:
//   - Message history (user and assistant messages)
//   - Context for the AI model
//   - State across multiple turns
//
// Threads enable multi-turn conversations where the agent remembers what
// was said earlier.
// ============================================================================

PersistentAgentThread thread = client.Threads.CreateThread();
Console.WriteLine($"\nStarted conversation thread: {thread.Id}");
Console.WriteLine("Chat with the Concert Concierge (type 'exit' to quit)\n");

// ============================================================================
// CONVERSATION LOOP: Handle User Interactions
// ============================================================================

while (true)
{
    // Get user input from console
    Console.Write("You: ");
    var userInput = Console.ReadLine();
    
    // Check for exit command
    if (string.IsNullOrWhiteSpace(userInput) || userInput.ToLower() == "exit")
    {
        Console.WriteLine("Goodbye!");
        break;
    }

    try
    {
        // ========================================================================
        // STEP 1: Send User Message to Thread
        // ========================================================================
        // Add the user's message to the conversation thread.
        // The thread now contains all messages: [previous messages..., new user message]
        // ========================================================================
        
        client.Messages.CreateMessage(
            thread.Id,
            MessageRole.User,    // Identifies this as a user message (vs assistant message)
            userInput);

        // ========================================================================
        // STEP 2: Run the Agent
        // ========================================================================
        // Create a "run" which tells the agent to process the thread's messages.
        // The agent will:
        //   1. Read all messages in the thread
        //   2. Decide what action to take (respond, call tool, etc.)
        //   3. Generate a response or request tool execution
        // ========================================================================
        
        ThreadRun run = client.Runs.CreateRun(thread.Id, agent.Id);

        // ========================================================================
        // STEP 3: Poll for Run Completion
        // ========================================================================
        // Runs are asynchronous. We poll the status until:
        //   - Completed: Agent finished and has a response
        //   - RequiresAction: Agent needs to call a tool (our code must execute it)
        //   - Failed: Something went wrong
        // ========================================================================
        
        do
        {
            await Task.Delay(500);  // Wait 500ms between status checks
            run = client.Runs.GetRun(thread.Id, run.Id);
        }
        while (run.Status == RunStatus.Queued || run.Status == RunStatus.InProgress);

        // ========================================================================
        // STEP 4: Handle Tool Execution Requests
        // ========================================================================
        // If run.Status == RequiresAction, the agent wants to call a tool.
        // We must:
        //   1. Execute the tool (call Ticketmaster API, run code, etc.)
        //   2. Return results to the agent
        //   3. Continue the run
        // ========================================================================
        
        if (run.Status == RunStatus.RequiresAction && run.RequiredAction is SubmitToolOutputsAction submitToolOutputsAction)
        {
            Console.WriteLine("\nüîß Agent requesting tool execution...");
            
            // Collection to hold results from all tool calls
            var toolOutputs = new List<ToolOutput>();
            
            // The agent might request multiple tool calls in sequence
            foreach (var toolCall in submitToolOutputsAction.ToolCalls)
            {
                // Check if this is a function tool call (vs built-in tool like code interpreter)
                if (toolCall is RequiredFunctionToolCall functionToolCall)
                {
                    Console.WriteLine($"   Calling: {functionToolCall.Name}");
                    
                    // ================================================================
                    // HANDLE: Ticketmaster Search Function
                    // ================================================================
                    // The agent has decided it needs concert data from Ticketmaster.
                    // We will:
                    //   1. Parse the arguments the AI provided
                    //   2. Call our Ticketmaster client
                    //   3. Return results as JSON
                    // ================================================================
                    
                    if (functionToolCall.Name == "search_ticketmaster_events")
                    {
                        try
                        {
                            // PARSE ARGUMENTS
                            // The AI provides arguments as a JSON string
                            // Example: {"city": "Munich", "countryCode": "DE"}
                            var functionArgs = JsonSerializer.Deserialize<Dictionary<string, JsonElement>>(
                                functionToolCall.Arguments
                            );
                            
                            // Extract each parameter, checking if it exists and is the right type
                            string? keyword = functionArgs?.ContainsKey("keyword") == true && 
                                             functionArgs["keyword"].ValueKind == JsonValueKind.String 
                                ? functionArgs["keyword"].GetString() : null;
                                
                            string? city = functionArgs?.ContainsKey("city") == true && 
                                          functionArgs["city"].ValueKind == JsonValueKind.String 
                                ? functionArgs["city"].GetString() : null;
                                
                            string? stateCode = functionArgs?.ContainsKey("stateCode") == true && 
                                               functionArgs["stateCode"].ValueKind == JsonValueKind.String 
                                ? functionArgs["stateCode"].GetString() : null;
                                
                            string? countryCode = functionArgs?.ContainsKey("countryCode") == true && 
                                                 functionArgs["countryCode"].ValueKind == JsonValueKind.String 
                                ? functionArgs["countryCode"].GetString() : null;
                                
                            string? classificationName = functionArgs?.ContainsKey("classificationName") == true && 
                                                        functionArgs["classificationName"].ValueKind == JsonValueKind.String 
                                ? functionArgs["classificationName"].GetString() : null;
                            
                            // Display what we're searching for
                            Console.WriteLine($"      Keyword: {keyword ?? "(none)"}");
                            Console.WriteLine($"      City: {city ?? "(none)"}");
                            Console.WriteLine($"      State: {stateCode ?? "(none)"}");
                            Console.WriteLine($"      Country: {countryCode ?? "(none)"}");
                            
                            // EXECUTE FUNCTION
                            // Call the Ticketmaster API with the extracted parameters
                            var searchResult = await ticketMasterClient.SearchEventsAsync(
                                keyword: keyword,
                                city: city,
                                stateCode: stateCode,
                                countryCode: countryCode,
                                classificationName: classificationName
                            );
                            
                            // SERIALIZE RESULT
                            // Convert the search results to JSON so the agent can process them
                            var resultJson = JsonSerializer.Serialize(searchResult, new JsonSerializerOptions 
                            { 
                                WriteIndented = false  // Compact JSON for efficiency
                            });
                            
                            Console.WriteLine($"      ‚úì Found {searchResult?.Embedded?.Events?.Count ?? 0} events");
                            
                            // RETURN RESULT TO AGENT
                            // Package the JSON result with the tool call ID
                            toolOutputs.Add(new ToolOutput(functionToolCall.Id, resultJson));
                        }
                        catch (Exception ex)
                        {
                            // HANDLE ERRORS
                            // If the API call fails, return an error message the agent can explain
                            var errorMessage = ex.Message;
                            if (ex.InnerException != null)
                            {
                                errorMessage += $" - {ex.InnerException.Message}";
                            }
                            Console.WriteLine($"      ‚úó Error: {errorMessage}");
                            
                            // Provide helpful error message to agent
                            var agentError = errorMessage.Contains("400")
                                ? "Failed to search Ticketmaster API (400 Bad Request). " +
                                  "This usually means invalid API key or malformed request. " +
                                  "Please verify the API key is set correctly."
                                : $"Error searching Ticketmaster: {errorMessage}";
                            
                            toolOutputs.Add(new ToolOutput(functionToolCall.Id, agentError));
                        }
                    }
                }
            }
            
            // ================================================================
            // SUBMIT TOOL OUTPUTS BACK TO AGENT
            // ================================================================
            // Send all tool execution results back to the agent.
            // The agent will then use these results to formulate its response.
            // ================================================================
            
            if (toolOutputs.Count > 0)
            {
                run = client.Runs.SubmitToolOutputsToRun(run, toolOutputs);
                
                // Continue polling - the agent now processes the tool results
                do
                {
                    await Task.Delay(500);
                    run = client.Runs.GetRun(thread.Id, run.Id);
                }
                while (run.Status == RunStatus.Queued || run.Status == RunStatus.InProgress);
            }
        }

        // ========================================================================
        // STEP 5: Display Agent Response
        // ========================================================================
        // If the run completed successfully, retrieve and display the agent's response.
        // ========================================================================
        
        if (run.Status == RunStatus.Completed)
        {
            // Get all messages in the thread, newest first
            var messages = client.Messages.GetMessages(thread.Id, order: ListSortOrder.Descending);
            var latestMessage = messages.FirstOrDefault();
            
            // Verify this is an assistant message (not a user message)
            if (latestMessage != null && latestMessage.Role.ToString() == "assistant")
            {
                Console.Write("\nAssistant: ");
                
                // Track any files the agent generated (e.g., PDFs from code interpreter)
                var fileIdsToDownload = new List<string>();
                
                // Process each content item in the message
                foreach (var content in latestMessage.ContentItems)
                {
                    // TEXT CONTENT
                    // Most responses are text content containing the agent's reply
                    if (content is MessageTextContent textContent)
                    {
                        Console.WriteLine(textContent.Text);
                        
                        // CHECK FOR FILE ANNOTATIONS
                        // When the Code Interpreter creates files, they appear as annotations
                        // Example: Agent creates a PDF ‚Üí annotation contains file reference
                        foreach (var annotation in textContent.Annotations)
                        {
                            if (annotation is MessageTextFilePathAnnotation filePathAnnotation)
                            {
                                fileIdsToDownload.Add(filePathAnnotation.FileId);
                            }
                        }
                    }
                    // IMAGE CONTENT
                    // If the agent generated an image
                    else if (content is MessageImageFileContent imageContent)
                    {
                        Console.WriteLine($"[Image File: {imageContent.FileId}]");
                        fileIdsToDownload.Add(imageContent.FileId);
                    }
                }
                Console.WriteLine();

                // ================================================================
                // DOWNLOAD GENERATED FILES
                // ================================================================
                // If the agent created any files (PDFs, images, etc.), download them.
                // Files from Code Interpreter are temporary and should be saved locally.
                // ================================================================
                
                if (fileIdsToDownload.Count > 0)
                {
                    Console.WriteLine($"\nüìé {fileIdsToDownload.Count} file(s) generated:");
                    foreach (var fileId in fileIdsToDownload)
                    {
                        DownloadFile(client, fileId, "file");
                    }
                }
            }
        }
        else
        {
            // Handle run failures
            Console.WriteLine($"\nRun failed with status: {run.Status}");
            if (run.LastError != null)
            {
                Console.WriteLine($"Error: {run.LastError.Message}\n");
            }
        }
    }
    catch (Exception ex)
    {
        Console.WriteLine($"\nError: {ex.Message}\n");
    }
}

// ============================================================================
// CLEANUP: Delete Resources
// ============================================================================
// Clean up the thread and agent to avoid accumulating resources.
// In production, you might keep threads for conversation history.
// ============================================================================

client.Threads.DeleteThread(thread.Id);
client.Administration.DeleteAgent(agent.Id);
Console.WriteLine("\nConversation thread and agent deleted.");

// ============================================================================
// HELPER METHOD: Download Files from Code Interpreter
// ============================================================================
/// <summary>
/// Downloads a file generated by the Code Interpreter tool.
/// Files are saved to the user's Downloads folder.
/// </summary>
/// <param name="client">The Azure AI Agents client</param>
/// <param name="fileId">ID of the file to download</param>
/// <param name="fileType">Type hint for naming (if filename not available)</param>
// ============================================================================

static void DownloadFile(PersistentAgentsClient client, string fileId, string fileType)
{
    try
    {
        // STEP 1: Get file metadata (filename, size, etc.)
        var fileInfoResponse = client.Files.GetFile(fileId);
        var fileInfo = fileInfoResponse.Value;
        
        // STEP 2: Extract filename
        // Code Interpreter returns paths like "/mnt/data/calendar.pdf"
        // We just want the filename part: "calendar.pdf"
        var rawFileName = fileInfo.Filename ?? $"{fileType}_{fileId}";
        var fileName = Path.GetFileName(rawFileName);
        
        Console.WriteLine($"  - {fileName}");
        
        // STEP 3: Download file content (binary data)
        var fileContentResponse = client.Files.GetFileContent(fileId);
        var fileContent = fileContentResponse.Value;
        
        // STEP 4: Determine save location (user's Downloads folder)
        var downloadsPath = Path.Combine(
            Environment.GetFolderPath(Environment.SpecialFolder.UserProfile), 
            "Downloads");
        var filePath = Path.Combine(downloadsPath, fileName);
        
        // STEP 5: Handle duplicate filenames
        // If "calendar.pdf" exists, save as "calendar_1.pdf"
        int counter = 1;
        while (File.Exists(filePath))
        {
            var nameWithoutExt = Path.GetFileNameWithoutExtension(fileName);
            var extension = Path.GetExtension(fileName);
            filePath = Path.Combine(downloadsPath, $"{nameWithoutExt}_{counter}{extension}");
            counter++;
        }
        
        // STEP 6: Save file to disk
        File.WriteAllBytes(filePath, fileContent.ToArray());
        Console.WriteLine($"    ‚úì Downloaded to: {filePath}");
    }
    catch (Exception ex)
    {
        Console.WriteLine($"    ‚úó Failed to download file {fileId}: {ex.Message}");
    }
}
